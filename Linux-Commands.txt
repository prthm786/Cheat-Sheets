                Linux Commands 

####### Terminal Shortcuts #######

Ctrl + Shift + C -> copy text 
Ctrl + Shift + V -> paste text 
Ctrl + L -> Clears the terminal 
Ctrl + A -> Move to start of line 
Ctrl + E -> Move to end of line 
Ctrl + U -> deletes everything before the cursor 
Ctrl + K -> deletes everything after the cursor 
Ctrl + Shift + + -> Increase font size 
Ctrl + - -> Decrease font size 
Ctrl + R -> search in history 
F11 -> Full screen mode 
Ctrl + C -> stops the execution of process
Ctrl + Z -> Backgrounds the process 
Alt Del -> Delete word by word
Alt Arrow Keys -> move word by word


bind '"\el":"clear\n"'  # alt l  # creating custom key binding for bash
bind '"\ef":"open $(pwd) \n"' # alt f

______________________________________


$ man <command>  # show manual page for <command>
$ <command> --help
$ whatis <command>
$ whoami
$ who 
$ which <command>    # show binary in only one place
$ whereis <command>  # show all the places
$ type <command or alias> 
$ type -t <command or alias> 
$ command -v/-p/-V <command>
$ date 
$ history 
$ history -c     # clears history 
$ history | sort -r | fzf  #  find within history 
$ watch <command>
$ time <command> # returns the time the command took to run 
# reset 
$ reboot # restarts the system 
$ sudo reboot -f
$ sudo shutdown
$ sudo shutdown -h now
$ sudo shutdown +15  # shutdown after 15 min
$ sudo shutdown +10 "System will shut down in 10 minutes" 
$ sudo shutdown -r +5 "System will reboot in 5 minutes" 
$ poweroff
$ sleep <seconds> 
$ clear 

$ ls /bin | grep <search>  # check for command binaries 


$ echo $?  # check if the last command was successful
$ !!  # runs the last command 
$ !<no> # runs the <no> command from history 

$ echo "<some_text>" # displays text on the screen
$ echo -e "<some_text>" # this option enable interpretation of escape sequences  



Running Multiple Commands 

$ <command1> ; <command2> # always runs both commands irrespective of the result of first command 
$ <command1> && <command2> # runs second command only if first command is successful 
$ <command1> || <command2> # runs second command if first command fails


$ Eg:- bat <file> || sudo apt install bat && bat <file>
 # using logical operstors to run command on conditions 


############# System Info #############
$ hostname 
$ cat /etc/hostname 

$ uptime 

$ dmidecode

$ uname 
$ uname -m 
$ uname -a  # show kernel info 

$ cat /etc/os-release 
$ cat /proc/cpuinfo  # Cpu information
$ cat proc/meminfo   # Memory information

$ man free 
$ free  # Show memory and swap usage
$ free -h 

$ man df 
$ df --help
$ df  # Show the disk usage 
$ df -h 

$ man du 
$ du --help
$ du  # Show directory space usage
$ du -h 

$ man uptime 
$ uptime # shows the time since last boot 
$ uptime | awk '{print $3}'

$ lsblk # list block devices 

$ lspci # list peripheral devices linke sound cards, graphic cards etc 

$ lsusb 
$ lscpu

$ sudo lshw  # provide all the hardware related info
$ sudo lshw -html >> report.html # export all the info in html file 
$ sudo lshw -short
$ sudo lshw -C disk
$ sudo lshw -C memory
$ sudo lshw -C cpu
$ sudo lshw -C network

$ aplay -l   

$ lsof
lsof -i :<port> 
$ lsof -i :22

______________________________________



########### File Management ###########

ls 
cd
popd
pushd
pwd
touch 
mdkir 
file 
mv 
cp 
tail
head
nano
rmdir 
rm
find 
tree 
chmod 
cat 
diff 
ln
unlink


Redirection/Data Streams

1> or >   # redirecting stdout to a file 
>>
2>        # redirecting stderr 

Eg:- find /etc -type f 1> ~/results.txt 2> ~/errors.txt


$ man ls 
$ ls --help
$ ls            # list files in directory 
$ ls -al        # list all files 
$ ls -alh       # list all files in long format (-l) in human readable form (-h) (file size)
$ ls -alFh
$ ls -ashSr1    # sorts all files (-a) by size (-S) in reverse order (-r) and also show size (-s)  
$ ls -ashtr1    # sorts all files (-a) by time (-t) in reverse order (-r) 
$ ls -ltu       # sort by the last time a file was accessed
$ ls -ai        # show inode number for all files
$ ls -a1        # show all files in each line 


$ man cd
$ cd --help 
$ cd <directory>
$ cd ..   # cd into the parent directory 
$ cd -    # cd into the previous directory 
$ cd ~    # cd into the current user's home directory
$ cd /    # cd into the root directory
$ cd      # cd into home directory 
$ pwd     # print current directory

$ pushd <directory> 
$ popd 

$ man mktemp
$ mktemp # creates a file
$ mktemp -d # creates a dir 
$ test=$(mktemp)
$ rm $(echo $test)

$ man touch
$ touch --help
$ touch <file>   # creating empty file
$ touch <file1> <file2> 
$ touch file{1..10} # creating 10 files

$ echo "<content>" > filename.txt   # creating a file with content 
$ echo "<content>" >> filename.txt  # appending to a file 

$ man mkdir 
$ mkdir --help
$ mkdir <dir_name> # creating directory 
$ mkdir dir{1..5} # makes 5 directories of name dir1, dir2,...dir5

$ man cp
$ cp --help
$ cp <file> <destination>/<file> # copies file into the destination
$ cp -i <file> <destination> # interactive copy 
$ cp -r <source_path> <destination> # copies the entire folder or multiple files recursively 
$ cp -v <file> <destination> # verbose copy 

$ man mv 
$ mv --help
$ mv <file> <destination> 
$ mv -v <file> <destination> 
$ mv -i <file> <destination>   
$ mv <filename> <newfilename> # renames file 

$ man tail 
$ tail --help
$ tail <file> # shows last 5 lines of a file 
$ tail -n <file> # last n lines of file 
$ tail -f <file>  # follows the file for updates 

$ man head 
$ head --help
$ head <file> # shows first 5 lines of a file 
$ head -n <file>  # first n lines of file 

$ man cat 
$ cat --help
$ cat <file>  # list all content of a file
$ cat > <file>  # places standard input to a file until Ctrl + C is pressed 
$ cat << EOF > <file>   # places all the input  until 'EOF' is received
$ cat -n <file>   # show line numbers 
$ cat <file1> <file2> > <newfile> # create a new file with content of both files <file1> and <file2> 
$ cat ./*.txt > merge.txt  # combines the contents of all the text files into one file 

$ bat <file> || sudo apt install batcat 

$ nano || sudo apt install nano # check for nano and install if it is not found 

$ man nano
$ nano --help
$ nano <file> # edit contents of a file
$ nano -l <file> # display line number in file 

$ rmdir <directory> # remove an empty directory
$ rmdir -v <directory>
$ man rm 
$ rm --help
$ rm <file> # removes a file 
$ rm -i <file> # removes file interactively 
$ rm -rf <dir> # removes contents of directories recursively
$ rm -rfv <dir> # removes contents of directories recursively with verbose (-v)

$ rm --dir <emptydir> # removes empty directory
$ rm ./*.txt  # removes all text files 

$ man shred 
$ shred -vzu # (-z or --zero) added zero in final overwrite to hide shredding, (-u or --remove) remove files, (-v) verbose 
$ shred -vz
$ shred -nz <number> # overwrite <number> times (-n or --iterations), (-z) added zero in final overwrite

$ file <file> # determine type of file 
$ stat <file>
$ wc <file> # display no of lines, words and bytes in a file

$ grep -i "<word>" <file> # find word within a file 
$ cat <file> | grep <word> 

$ fzf || sudo apt install fzf 
$ fzf --preview='batcat --color=always {}'
$ gedit $(fzf --preview="batcat --color=always {}")

$ man find 
$ find --help
$ find <dir> -name <pattern> -exec <command> {} +
$ find . -type f -empty  # finding empty files in current directory
$ find . -type d   # find directories
$ sudo find / -name "<name>" 
$ sudo find / -iname "<name>"
$ find ~/Desktop -type f -name "*.txt" -exec cat {} \;
$ find /var/log -type f -name "*.log"
$ find ~/test -type f -name "*.txt" -delete # delete all the text files using find command 
$ find . -mtime +10 # find all the files that was not modified for more than 10 days 
$ find . -type f -size +1M # find files which are greater than 1 Megabyte 

$ fdfind || sudo apt install fd-find  # install fd which faster alternative to find
$ fdfind <pattern> <path> 
$ fdfind --type f  
$ fd -t e # or empty # find empty files 
$ fd --type x # or executable 
$ fd -t l # or symlink 
$ fdfind -d 1 -td    # finds all the directories inside the current directory with a depth of 1
$ fdfind -d 1 -td | fzf 
$ fdfind -d 1 -tf | fzf 
$ fd -e pdf # find all pdfs inside the current dir
$ fd -e txt -E "*test*" # find all txt files test the file with test in it
$ fd -S +12m -e pdf   # find all pdf files with a size greater than 12MB
$ fd -S -12m -e docx   # find all docx files with a size less than 12MB
$ fd -e zip -x unzip

$ chmod <file_permissions> <file>   # changes file mod 
$ tree                     # Lists the contents of a directory recursively

$ ln <source> <file_link> $ creates a hard link 
$ ln -s <source> <file_link> # creates a soft link

$ truncate -s 0 <file>

$ man diff 
$ diff --help
$ diff <file1> <file2> # shows the difference between 2 files 
$ diff -u <file1> <file2>
$ diff -q <file1> <file2>
$ diff -r <dir1>/ <dir2>/

______________________________________



######### Output Handling #########

awk
grep
more 
less 
head 
tail
sed 
tr
wc
cut 

$ ls -al | wc -l # prints no of files in current directory 

$ cat /var/log/auth.log | less


$ man awk
$ awk --help
awk ‘{action}’ <file>
awk ‘/regex pattern/{action}’ <file>


$ awk ‘{print $0}’ <file>  # print all the contents of a file similar to cat 
$ awk ‘{print NR,$0}’ <file>  # line number count with the line 
$ awk ‘{print $1}’ <file>     # print specific column
$ awk ‘{print $1, $4}’ <file> # print 2 columns
$ awk ‘{print $NF}’ <file> # print last column
$ awk -F "<delimiter>" "{print $0}" <file>
$ awk 'length($0) > 10' <file> # print if length of line is greater than 10 
$ awk 'NR==3, NR==6 {print NR,$0}' <file> # prints the line between  line 3 and 6 
$ awk '{print NR " - " $1 }' <file>

$ awk ‘/^O/’ <file>
$ awk ‘!/0$/’ <file> 
$ awk ‘/<pattern>/ {print $0}’ <file> # prints lines with <pattern>
$ awk '/alias/ {print}' .bashrc # prints lines that contains 'alias' 

$ awk '{if($NF == "<something>") print $0} # prints the whole line if last column is equal to something 
$ awk 'END {print NR}' <file> # prints no of files in a file 

$ man grep
$ grep --help
grep <pattern> <file>

$ grep -i "<word>" <file> # case insentive 
$ grep -v "<word>" <file> # show lines that does not contain the word (invert)
$ grep -n "<word>" <file> # display line numbers that contain the <word>
$ grep -c "<word>" <file> # count no of matching lines or count no of occurrences 
$ grep -r "<pattern>" <directory> # search tha pattern within multiple files recursively 
$ grep -l "<pattern>" <directory> # print files with the match 
$ grep -L "<pattern>" <directory> # print files without the match 
$ grep -A <num> "<word>" <file> # shows lines after the match
$ grep -B <num> "<word>" <file> # shows lines before the match
$ grep -C <num> "<word>" <file> # shows lines before & after the match
$ grep -l <pattern> * # check in all the files in the directory 
$ grep -Irl # for not binary and recursive only file names

$ rg || apt install ripgrep # installs ripgrep which is faster and more versatile than grep


$ man sed 
$ sed --help
sed ‘s/[regex]/[replacement]/[flags]'  <filename>


$ sed ‘s/cat/concatenate/g’ <file>  # replaces every word 'cat' with 'concatenate' 


$ sed ‘2,3s/cat/concatenate/’ <file>   # replace 2nd and 3rd 'cat' with 'concatenate' 

$ sed ‘3d’ <file>   # delete 3rd line 


$ tr  # translate or transliterate 
$ echo "Hello World" | tr [a-z] [A-Z]              # HELLO WORLD 
$ echo "Hello World" | tr [:lower:] [:upper:]      # HELLO WORLD 
$ echo "Hello World" | tr -d [a-z] # H W           # delete chars
$ echo "Hello World" | tr -d [A-Z] # ello orld     # delete chars
$ tr -s # remove duplicate chars 
$ echo "Helllo Woorlddd" | tr -s "l"               # Helo Worlddd
$ echo "Hello World123" | tr -d [:alpha:] # 123    # delete all alphabets 
$ echo "a1b2c3d4" | tr -d '0-9'  # abcd            # remove all numbers 
$ echo "a1b2c3d4" | tr -d '[:digit:]'
$ echo "hello     world" | tr -s ' '
$ echo "aabcd    sdgdgs" | tr -s '[:space:]'
$ echo "aabcd sdgdgs" | tr -d ' '
$ echo "aabcd sdgdgs" | tr -d '[space]'
$ echo "aabcd    sdgdgs1219422522353   %^&*^" | tr -s '[:space:]' | tr -d '[:alnum:]'

______________________________________



########### Networking ############

ip
ifconfig 
netstat 
ping 
ssh 
nslookup
curl 
wget 
arp
route 

$ man netstat 
$ netstat --help
$ netstat -r       # display routing table 
$ netstat -l       # all listening ports 
$ netstat -tln     # display all listening TCP ports 
$ netstat -uln     # display all listening UDP ports 
$ netstat -plunt   # display all listening TCP and UDP process with processid 

$ ss -tulpn

$ man ping 
$ ping --help
$ ping <host> 
$ ping -vc <number> <host>  # number of packets to send to the host
$ ping -s <size> -vc <number> <host> # specify size of each packet to sens to the host 

$ ping -c <number> -q <host>   # only get the summary
$ ping -i <interval> <host>   # default ping wait for 1 sec to send next packet change this time by using -i 
$ ping -f <host>   # ping flood 
$ ping -c 4 -s 128 <url>   

# traceroute

$ man nslookup
$ nslookup <host>
$ nslookup -query=mx <host>
$ nslookup -query=txt <host>
$ nslookup -query=ns <host>
$ nslookup <host> <dns_server> 

$ man dig  # DNS lookup utility
$ dig <host>
$ dig <host> TXT   # MX / TXT / NS / AAAA / PTR  # query any dns record
$ dig @<dns_server> <host>
$ dig -x 127.0.0.1 # reverse lookup
$ dig +stats <host> 

$ sudo apt install curl # installs curl 
$ man curl 
$ curl --help

$ curl <url> # display the content of the URL on the terminal

$ curl http://localhost:<port> 

$ curl -v <url>  # displays more information 
$ curl -i <url> # to include response headers
$ curl -I <url> # to only view response headers 

$ curl -o <output_file> <url> # download file from the url 
$ curl -O <url>   # saves it with the same name as in the <url>
$ curl -O <url1> <url2> # downloads multiple files 
$ curl -# -O <url> # displays progress bar while downloading 

$ curl -X <HTTP_Method> <url> # use specific HTTP request method instead of GET Method 
$ curl -X PUT <url> # making a PUT request 
$ curl -X DELETE <url> # making a DELETE request 

$ curl -H '<headers>' <url>  # used to send a request with specific headers 

$ curl -X POST <url> -H 'Content-Type: application/json' -d '{"key1":"val1", "key2":"value2"}' # used for sending json data using POST request 
OR
$ curl <url> -H 'Content-Type: application/json' -d '{"key1":"val1", "key2":"value2"}' # used for sending json data using POST request 
# when -d [or --data] is used the HTTP Method changes to POST automatically 

$ curl --data "param1=&param2=" <url>
$ curl -X POST -d "param1=John&param2=Doe" <url> # For making a POST request to a server 

$ curl -u <username>:<password> -T <file_to_upload> <ftp_url>  # upload a file to the FTP server


$ man wget 
$ wget --help
$ wget <url>
$ wget -O <file> <url>

$ man ip
$ ip -4 addr      # show ipv4 address 
$ ip -6 addr      # show ipv4 address 

$ ip address 
$ ip address | grep <interface>
$ ip addr show 
$ ip address show <interface> # show the information related to all interfaces available on our system
$ ip neigh show
$ ip neigh flush all
$ ip neigh flush dev <interface> 

$ nmcli
$ nmcli device show

$ resolvectl
$ resolvectl statistics
$ resolvectl flush-caches
$ resolvectl query <domain>    # add ip info to local dns

$ sudo dhclient -r <interface>  # release ip address
$ sudo dhclient <interface>     # renew ip address

$ man arp
$ arp -a/-e

$ cat /etc/resolv.conf
$ cat /etc/hosts 

SSH
~/.ssh/config

$ sudo apt install openssh-client # installs ssh client o n the system

$ ssh -vv <user>@<ipaddress> # login to a remote server using IP address 
$ $ ssh -p <port> <user>@<ipaddress> # specify a different port to connect to SSH server 
$ ssh <user>@<ipaddress> <command> # uses ssh to run a single command 
$ ssh -i <private_key_file> <user>@<ipaddress> # connecting to a server using a private key 

$ ssh-keygen -t rsa -b 4096 # creating a key pair 

$ ssh-copy-id -i <public_key> <user>@<ipaddress> # copies the public key file to the server 


SCP
$ scp <username>@<ipaddress>:<remote_path> <local_path> # copy file from remote server locally 

$ scp -r <username>@<ipaddress>:<dir_path> <local_dir_path> # copy entire directory recursively from remote server locally 


$ SCP -P <port> <file> <username>@<ipaddress>:<path> # uses different port than 22 to connect to the server and transfer files 

$ scp <local_path> <username>@<ipaddress>:<remote_path> # copy file to the remote server 

$ scp -r <local_dir_path> <username>@<ipaddress>:<dir_path> # copy entire directory recursively to remote server


SFTP
$ sftp <username>@<ipaddress>
$ sftp -i <private_key_file> <user>@<ipaddress>

Rsync

______________________________________



########## User Management ########## 

$ whoami

# /etc/passwd
# /etc/group
# /etc/default/useradd
# /etc/shadow
# /etc/sudoers

adduser 
useradd  # lazy way of creating user 
deluser/userdel
passwd 
addgroup/groupadd
usermod 
groups 
groups –current user
gpasswd
groupadd
visudo # for changing group permissions 
delgroup/groupdel
groupmod
users
sudo
su

$ cat /etc/passwd     # this file has username and password 
$ cat /etc/shadow     # holds encrypted password of user accounts
$ cat /etc/group      # contains group info for all accounts
$ cat /etc/gshadow 

$ cat /etc/passwd | cut -d: -f1                  # prints all the users on the system 
$ cat /etc/passwd | awk -F ':' '{print $1}'      # prints all the users on the system 

$ adduser --help
$ sudo adduser <usermame> # create a new user 

$ useradd --help
$ sudo useradd <username> # lazy way of creating user 
$ sudo useradd <username> -m # createa new user and adds home directory for the user 

$ passwd --help
$ sudo passwd <user> # change password for <user>
$ sudo passwd  # change password for current user 
$ sudo passwd -l <user> # lock user out 
$ sudo passwd -u <user> # unlocks the user 
$ sudo passwd -x <days> <user> # days for which password will be valid 
$ sudo passwd -n <days> <user> # minimum days for user cannot change it's password 
$ sudo passwd -d <user> # to delete password for the user 
$ passwd -S/--status 

$ echo "username:new_password" | sudo chpasswd # change user password 

$ su - <user>   # switches to <user>
$ su -          # switches to root, require root credentials 

$ usermod --help
$ sudo usermod -l <username> <newusername>  # change <username> of the <user>
$ sudo usermod <username> --shell /bin/bash 
$ sudo usermod -aG sudo <user>  # give sudo priviledges  # append user to sudo group  

$ groupadd --help
$ sudo groupadd <group_name> # Removes a group from the system

$ sudo usermod -aG <group> <user> # add user to the group 
$ sudo usermod -aG sudo <user> 

$ groups 
$ groups <username>

$ userdel --help
$ sudo userdel <user> # Deletes a user account and related file

$ gpasswd --help
$ gpasswd -d <username> <groupname>

$ sudo visudo 

______________________________________



######### Process Handling #########

$ top 
$ nice 
$ renice
$ ps   
$ ps -aux or ps aux # shows all processes (-a) with user as root (-u) & have a tty (-x)
$ ps -r 
$ ps -axo user,pid,ppid,pcpu,pmem,rss,time,stime,comm 
$ ps -u <username> -o user,pid,ppid,pcpu,pmem,rss,time,stime,comm
$ ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm
$ ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm
 
$ ps -l # shows priority and niceness value 
$ ps -axo user,pid,ppid,pcpu,pmem,rss,time,stime,comm | sort -rk 4 | head   # sort according to CPU

$ kill -l 
$ kill -9 <processid> # ends a process 
$ pkill f <processname>  # ends a process using processname
$ killall <processname>

$ man ps
$ ps --help

$ man top
$ top --help
$ top -u <username> # see the processes for a particular user 

# Use ctrl + Z to make a process a background job 

$ <command> &   # runs the command in background 

$ fg  # Brings the most recent job to foreground
$ fg <n>  # Brings job <n> to the foreground

$ bg  # List stopped or background jobs,resume a stopped job in the background

$ jobs  # Lists all processes that are running in the background


$ htop || sudo apt install htop && htop  # checks if htop is installed if not installs and runs it 

______________________________________



####### Package Management ########

APT Package Manager
# /etc/apt
# /usr/lib/apt
# /var/log/apt

$ man apt 
$ apt --help 

$ sudo apt update && sudo apt upgrade
# updates the repositories and downloads all the updates 

$ sudo apt edit-resources

$ sudo apt update # update apt repo sources 
$ sudo apt upgrade # upgrade all package, install new versions 

$ sudo apt dist-upgrade

$ sudo apt search <string> 
$ sudo apt search –full <string>
 
$ apt show <package> # shows info about a package 

$ sudo apt install --dry-run <package> # see all packages that wiil be installed without actually installing  
$ sudo apt install --show-progress <package> # installs a new package 
$ sudo apt reinstall <package>
$ sudo apt remove <package> 
$ sudo apt remove --dry-run <package> 
$ sudo apt autoremove

$ sudo apt purge <package> # delete conf files as well
$ sudo apt install –-only-upgrade --show-progress <package> # updates a existing package

$ apt list --manual-installed 
$ sudo apt list –-installed # shows all installed packages
$ sudo apt list --installed | wc -l   # list no of packages installed 

$ sudo apt list --upgradable
$ sudo apt show <package> # give details about the package

$ sudo apt-cache search <package>
$ sudo apt-add-repository <repository>

$ dpkg -l
$ sudo dpkg -i <deb_file>


Snap Package Manager
# /snap/
# /var/snap/bat
# ~/snap/

$ sudo apt install snapd # install the snap package manager 

$ man snap
$ snap --help

$ sudo snap install <package> # installs package 
$ sudo snap find <package> # searches for package
$ sudo snap info <package> # gives details about the package
$ sudo snap refresh # updates all the package 
$ sudo snap refresh <package> # only updates a single package 
$ sudo snap list # list of packages install using snap 
$ sudo snap enable/disable <package>
$ sudo snap remove <package> # removed the package from the system 
$ sudo snap remove <package> --purge
$ snap log 


Flatpak Package Manager
# /var/lib/flatpak
# /var/lib/flatpak/app
# /home/<user>/.var/app/
# /home/<user>/.local/share/flatpak

$ sudo apt install flatpak # install the flatpak package manager
$ flatpak remote-add --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo

$ flatpak install flathub
$ flatpak --user install flathub 

$ flatpak info <package> 
$ flatpak search <package>  # searches for package
$ flatpak list 
$ flatpak list --app
$ flatpak update <package> 
$ flatpak uninstall <package> 
$ flatpak uninstall --unused  
$ flatpak run <package> 
$ flatpak ps 
$ flatpak kill <app_name> 

______________________________________



######### Service Handling #########

$ cat /etc/services 
/etc/systemd/system
/run/systemd/system
/lib/systemd/system

/lib/systemd     # systemctl
/etc/init.d      # service

$ sudo systemctl status <servicename>
$ sudo systemctl start <servicename>
$ sudo systemctl stop <servicename>
$ sudo systemctl restart <servicename>
$ sudo systemctl enable/disable <servicename>
$ sudo systemctl reload <servicename>
$ sudo systemctl is-active <servicename>
$ sudo systemctl is-enabled <servicename>
$ sudo systemctl list-units --all 
$ sudo systemctl list-units --type=service 
$ sudo systemctl list-unit-files 

$ systemd-analyze blame

______________________________________



########### Firewall ###########

ufw 
/etc/default/ufw

$ sudo apt install ufw # installs ufw on the system 
$ man ufw
$ ufw --help

$ sudo systemctl status/enable ufw
$ sudo systemctl start ufw 

$ sudo ufw status 
$ sudo ufw status verbose
$ sudo ufw status numbered 
$ sudo ufw delete <number>
$ sudo ufw enable/disable/reload 
$ sudo ufw allow/deny/reject http/tcp or 80
$ sudo ufw allow/deny/reject ssh/https/ftp

$ sudo ufw allow/deny from <ipaddress>
$ sudo ufw allow from <ipaddress> to any port <portno>
$ sudo ufw allow from <ipaddress> to any port <portno> proto <protocol>
$ sudo ufw allow from <ipaddress> to any port 22 proto tcp
$ sudo ufw allow/deny from <subnet>
$ sudo ufw allow from <ip> to any port 22

$ sudo ufw default allow outgoing
$ sudo ufw default deny incoming

$ sudo ufw delete <action> <to>
$ sudo ufw delete allow 80

$ sudo ufw deny/allow out <port>/tcp # deny or allow traffic for outgoing via <port>
$ sudo ufw limit <port>/tcp

$ sudo ufw app list
$ sudo ufw reset  # resets all the rules in ufw 
$ sudo ufw allow/deny <app> # allow or deny an application through ufw 

______________________________________



###### Compression/Decompression ######

tar 
gzip -> gzip command compresses file 
gunzip
zip and unzip 
zstd 

Gzip and Gunzip

# Gzip only works on a file, it fails to work on directory 
# To compress a directory we use zip or combine gzip with tar 

$ gzip --version || sudo apt install gzip && gzip --version    # check if gzip is installed and if not installs it 
$ man gzip
$ gzip --help

$ gzip <file>  # create a compressed file named <file>.gz 
$ gzip -k <file>  # by default gzip deletes original file but -k keeps the original file as well 
$ gzip -1 <file>  # sets compression level between 1-9, -1 -> least compression  and -9 -> max compression
$ gzip -d <file>.gz  # Decompression
$ gzip -l <file>.gz 

$ gunzip <file>.gz # decompresses


.tar - archive files are usually not compressed.
.tar.gz – archive file compressed with gzip tool
.tar.bz2 – archive file compressed with bzip2 tool

-A	Append tar files to an existing archive.
-d	Show differences between an archive and a local filesystem.
-delete 	Delete from the archive.
-u	Append but don’t overwrite the current archive.

$ man tar 
$ tar --help

$ tar -cvf file.tar <multiple_files>    # creates a new tar file (-c) with filename (-f) & verbose flag (-v) 
$ tar -cvf file.tar <folder>            # creating a tar Archive from folder

$ tar -tvf file.tar                     # list the contents of archive (-t)
$ tar -tvf file.tar | wc -l             # printing the no of files in tar archive 

$ tar -xvf file.tar                     # Extracting files (-x) from Archive from file (-f) & verbose flag (-v) 

$ tar -rvf existing-archive-name.tar <folder>  # Add files to the existing archive (-r)


$ tar -czvf <file>.tar.gz <folder>      # creates a new gzip compressed (-z) tar file (-c) with filename (-f) & verbose flag (-v) 

$ tar -tvf <file>.tar.gz                # listing the contents of tar.gz file (-t) 

$ tar -xvzf <file>.tar.gz               # Extracting a gzip tar Archive *.tar.gz (-x) 

$ tar -czf file.tar | wc -c  # checking size of tar 
$ tar -czf file1.tar.gz | wc -c  # checking size of tar.gz


Zip and Unzip 

$ zip --version || sudo apt install zip && zip --version
$ man zip
$ zip --help

$ zip <file>.zip <files_to_be_zipped> # compress files
$ zip <file>.zip <folder>
$ zip -2 <file>.zip <files_to_be_zipped>  # specify compression level (1-9)
$ zip my_archive.zip file1.txt file2.txt 

$ zip -v <file>.zip <folder>  # verbose 

$ zip -r <file>.zip <directory> # creates a zip file recursively 
$ # zip -r backup.zip . 

$ zip <file>.zip <folder> -x <file_to_exclude>   # exclude files from the zip 

$ zip -d <file>.zip <files_to_delete>            # deletes a file from within the archive 
$ zip -d my_archive.zip file_to_remove.txt

$ zip -u <file>.zip <files_to_add> 

$ zip -e secure_archive.zip sensitive_file.txt   # create a password-protected ZIP file 
$ zip -re <name>.zip <folder>                    # zip & encrypt a folder with a password

$ unzip --help
$ unzip <file>.zip
$ unzip <file>.zip -d <destination_path>

zstd

$ zstd || sudo apt install zstd

$ zstd -2 <file>  # specify compression level (1-19)

$ zstd --rm <file> -o <file>.zst # removes the source file after compression

$ zstd file.txt -o compressed.zst  # compress file 
$ zstd -vv file.txt -o compressed.zst  # compress file 
$ zstd -r <folder> -o myfile.zst # compress a folder 

$ zstd -d file.txt.zst # decompress
$ zstd -d file.txt.zst -o restored.txt # decompress 

$ unzstd file.txt.zst # decompress

______________________________________



########## Logs ##########

/var/log/
/var/log/auth.log 
/var/log/apt/ 

$ ls -al /var/log # logs are stored

$ sudo tail -f /var/log/auth.log 
$ sudo cat /var/log/auth.log | grep "<pattern>"

$ sudo tail -f /var/log/syslog

$ man last 
$ last # used to see the contents of /var/log/wtmp which contains info about last logged in users 
$ last -aF 

$ man lastb 
$ lastb # used to see the contents of /var/log/btmp which contains info about bad log in attempts
$ lastb -aF 

$ man lastlog
$ lastlog # used to see the last login of a user /var/log/lastlog
$ lastlog -u <user>

______________________________________




$ nano -l ~/.bashrc  # edit the bashrc file var/log/auth.log

if [ -f ~/.bash_aliases ]; then
 . ~/.bash_aliases
fi
$ source ~/.bashrc  # reloading .bashrc file 



##### Aliases #####

$ alias --help
$ alias <aliasname>="<alias_content>"
Eg:- alias i="sudo apt install"
     alias upg=”sudo apt update && sudo apt upgrade“

$ unalias <alias_name> # delete aliases 

$ alias | wc -l


######## Environment Variables ########

USER   # The currently logged-in user name
HOME   # The path to the current user’s home directory
SHELL  # The pathname of the current user’s shell
PATH   # A list of directories that the shell searches for executable files
PWD    # The path to your current working directory
UID    # The current user’s unique identifier
RANDOM # prints a random number 

$ echo $<variable_name> # display value of variables

$ echo $SHELL  # display value of SHELL variable 
$ echo $PATH  # display value of PATH variable

$ env  # prints all environment variables





# Creating a Environment Variable
$ export <var_name>=<var_value>

$ printenv 
$ printenv $<variable_name> # printing it's value 
$ printenv | grep <variable_name> # find a variable 

# To make a environment variable persistent Add a variable definition to the .bashrc file 

$ nano -l ~/.bashrc
 export <var_name>=<var_value>

$ source ~/.bashrc # reloads the bashrc file 


$ To make a variable accessible system wide add it to /etc/environment file

$ sudo nano -l /etc/environment
 export <var_name>=<var_value>

$ source /etc/environment

______________________________________




